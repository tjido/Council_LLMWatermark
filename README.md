# Council_LLMWatermark
This project seeks to embed a watermark feature into text generated by an LLM.

## Overview 
### ChatGPT-PDF Integration with Council.ai: Distinguishing LLM Output

This project focuses on the development of a sophisticated chatbot solution that can ingest PDF documents from your local drive, enabling queries using ChatGPT. A unique challenge is introduced: the necessity to differentiate content generated by Large Language Models (LLMs) from content originating in PDFs. To address this challenge, we'll harness the capabilities of the Council.ai package and framework. Our inspiration stems from Alistair Croll's work outlined in the Wired article ["To Watermark AI, It Needs Its Own Alphabet"](https://www.wired.com/story/to-watermark-ai-it-needs-its-own-alphabet/).

## Requirements

- Python 3.x
- Required Python packages listed in `requirements.txt`

## Project Structure

```plaintext
.
├── chatbot_controller.py
├── council
│   ├── ...
│   └── ...
├── document_retrieval.py
├── evaluator.py
├── llama_index
│   ├── ...
│   └── ...
├── prompt.py
├── watermake_ai.py
├── msft-10K-2022.pdf
└── main.py

## Getting Started
1. Install the required Python packages using `pip install -r requirements.txt`.
2. Download the 'msft-10K-2022.pdf' document as the PDF source for testing.
3. Configure the constants and inputs in the `main.py` script.
4. Run the script using `python main.py`.

## Implementation Details
The project involves the following main components:
- **PDF Ingestion:** The PDF document is ingested using the Council.ai framework, facilitating text extraction and processing.
- **Unicode Watermarking:** Inspired by Alistair Croll's approach, we employ Unicode characters as a watermarking mechanism to differentiate LLM-generated content from PDF content.
- **Chatbot Agent:** An AI agent is created using the Council.ai framework. It executes a process where chunks of text are processed, and messages are generated through various skills and chains.
- **Output Processing:** The output from the LLM is processed to highlight LLM-generated text and differentiate it from other content.

## Acknowledgments
We acknowledge Alistair Croll's pioneering work in watermarking AI-generated text with Unicode characters, as detailed in the Wired article ["To Watermark AI, It Needs Its Own Alphabet"](https://www.wired.com/story/to-watermark-ai-it-needs-its-own-alphabet/).

## Disclaimer
This project is experimental and is based on the principles outlined in the provided articles by Alistair Croll. The success of the Unicode chain method in distinguishing LLM output is a hypothesis we seek to validate through implementation and testing.

Feel free to contribute, collaborate, and explore new dimensions in AI transparency and recognition through Unicode watermarking.

# Additional Notes

# Differenciating AI content from Human Content Using UNICODE VALUES

The Idea behind this Work is Motivated by this post. 

### IDEA
Mark AI-written text with different Unicode values so that we can distinguish AI-written text from human-written text even though the letters look the same. Unicode works across all devices and websites, and doesn’t need any changes to how people use the Internet. Plus, the people behind the Unicode governing body include many of the companies who are building Generative AI.

A world where we can tell the difference between human- and machine-generated content is better for humanity. We have labels for the things we put in our bodies; we should care as much about what we put in our minds.


### Step to reproduce the code.

1. cd to chatbot repo `cd chatbot`
2. install requirements `pip install -r requirements.txt`
3. run `python main.py` on the terminal
4. After running the `main.py` file, the input will pop up.
    - enter pdf file name. eg: `msft-10K-2022.pdf`
    - enter company  name. eg: `Microsoft`
    - Query the pdf file: `How is the financial performance of Microsoft?`
5. The Output displays on the command line for both 
    - Hidden Unicode WaterMark AI Text
    - AI Output
    - Human Output

### Logic for the Unicode AI WaterMark 
Watermarking text using Unicode characters to differentiate between AI-generated and human-written content.

1. Embedding the Watermark: The embed_watermark function adds the hidden watermark to the original text. It works like this:
    - This function takes the original text and the watermark you want to hide. It goes through each character in the text:

    If the character is a letter, it adds the next character from the watermark followed by the letter itself. This hides the watermark within the text. If the character is not a letter (like a space or punctuation), it just adds the character as it is.

2. Revealing the Original text: The goal is to reveal the text from the watermarked text. Here's how the reveal_watermark_text function does it:

- This function goes through the watermarked text and checks each character:

    If the character matches the next watermark character, it means we've found a watermark character. So, we move to the next watermark character.
    If the character doesn't match, it's a regular letter, so we add it to the revealed text.
    
    This code uses the reveal_watermark function to extract the hidden watermark and prints the revealed text.

#### Chatbot Output

![Chatbot Output](chatbot\watermark_ai.png)



